:page-partial:

[[aspect-model-java-tooling]]
= Java Tooling for Working with Aspect Models

[[general-considerations]]
== General Considerations

In this section, the Java APIs for working with Aspect Models are described. All of the components described in the
following subsections can either be included in your project using a dedicated dependency (as described in the
respective subsection), _or_ you can use the `aspect-model-starter` artifact that aggregates all necessary dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-starter-artifact.adoc[]

The error handling in many APIs is done using the
`https://javadoc.io/doc/io.vavr/vavr/0.10.3/io/vavr/control/Try.html[Try]` type provided by the Java
library _Vavr_. This is similar to a `java.lang.Optional` in that a successful result can be
processed using `.map()` or `.flatMap()`, but if an error occurs, the object can also provide the
original exception using the `getCause()` method. Compared with throwing exceptions, using a
`Try<T>` as a return type instead has the advantage of enabling composable error handling. Please
see the https://www.vavr.io/vavr-docs/[Vavr User Guide] for more information.

You generally have multiple options for handling `Try<T>` results, similar to dealing with `Optional`:

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$HandlingTry.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$HandlingTry.java[tags=handlingTry]
----

[[versioning]]
== Getting the right version

The tooling can be made available in two different versions: `release` and `milestone`. The release version represents a stable version of the product
and can be referenced in your projects in the usual way from the Maven Central repository. There is also the possibility to have the intermediate builds
made available, these are called `milestone` builds. Instead of Maven Central, these are released via 
https://github.com/orgs/eclipse-esmf/packages?repo_name=esmf-sdk[GitHub Packages] mechanism. +
To be able to use the artifacts released in this way in your projects, first the right repository has to be added to your `pom.xml` file:
[source, xml]
----
<repositories>
  <repository>
    <id>github</id>
    <name>ESMF SDK</name>
    <url>https://maven.pkg.github.com/eclipse-esmf/esmf-sdk</url>
    <releases><enabled>true</enabled></releases>
    <snapshots><enabled>true</enabled></snapshots>
  </repository>
</repositories>
----
Then the desired dependencies can be referenced in the usual way. For an example, please refer to 
https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-apache-maven-registry#installing-a-package[Github - Installing a package].

[[jdk-requirements]]
== JDK requirements

The esmf-sdk components are built with Java 17 and require a JDK >= 17 such as
https://adoptium.net/[Adoptium Temurin].

The esmf-sdk can also be used with a Java 17-compatible https://www.graalvm.org/[GraalVM JDK]. With
GraalVM you need to make the Graal JavaScript component available, as parts of the SDK such as the
Aspect Model validation component require embedded JavaScript execution:

* For using the esmf-sdk in the GraalVM itself, install the JS component using the
  https://www.graalvm.org/22.3/reference-manual/js/[GraalVM Updater]: `gu install js`
* For using the esmf-sdk with GraalVM `native-image`, be sure to use the `--language:js` option when
  building the native image; for more information see
  https://www.graalvm.org/22.3/reference-manual/polyglot-programming/[polyglot programming].

[[parsing-aspect-model-urns]]
== Parsing Aspect Model URNs

The `aspect-model-urn` artifact provides a way to parse and validate Aspect model element URNs as described in the
xref:samm-specification:ROOT:namespaces.adoc[specification].

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$ParseAspectModelUrn.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$ParseAspectModelUrn.java[tags=parseAspectModelUrn]
----

To include the artifact, use the following dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-urn-artifact.adoc[]

[[loading-and-saving]]
== Loading and Saving Aspect Models

Aspect models are, like their Meta Model, described using the Resource Description Format (RDF,
xref:samm-specification:appendix:appendix.adoc#rdf11[[rdf11\]]) and the Terse RDF Triple Language syntax (TTL,
xref:samm-specification:appendix:appendix.adoc#turtle[[turtle\]]). There are two ways of working with Aspect models:
Either the model is loaded as an RDF model where the abstraction level directly corresponds to the RDF/Turtle
serialization, or the RDF is parsed into a native Java Aspect model representation where the abstraction level
corresponds to the SAMM concepts. Both approaches have different use cases and advantages and both are supported by the
Aspect model Java tooling:

[width="100%", options="header", cols="50,50"]
|===
| Working on the RDF level | Using the Java Aspect model
a|
* Low level, focus on power and flexibility
* Flexibly navigate and filter the model on the RDF statements level
* Work with models that are valid RDF, but incomplete Aspect models, e.g. in Aspect model editors
* Use SPARQL xref:samm-specification:appendix:appendix.adoc#sparql[[sparql\]] to execute complex queries on Aspect models
a|
* High level, focus on convenience and type-safety
* Use Aspect-model specific interfaces for type-safe code
* Use Java-native data types (e.g. `java.math.BigInteger` for `xsd:integer`)
* Easily traverse the model on the abstraction level of Aspect model elements
|===

As a rule of thumb, if your use case mostly consists of _consuming_ Aspect models, you should prefer the Java Aspect
model, if you _create_ or _edit_ Aspect models, this is better done using the RDF API.

[[understanding-model-resolution]]
=== Understanding Model Resolution

Loading an Aspect model in either the RDF-based or the Java Aspect model-based APIs does not only comprise parsing the
Turtle file, but also the resolution of elements on the RDF level:

* An Aspect model refers to meta model elements (everything that starts with `samm:`), and can refer to namespaces of
  shared elements (`samm-c`, `samm-e` and `unit`)
* It can also refer to elements from other Aspect models or model elements defined in separate Turtle files

You use the _model resolver_ to load an Aspect model, which takes care of the first point: The used meta model elements
and elements from shared namespaces are automatically resolved and added to the loaded RDF model. For the second point,
you need to provide the model resolver with the information on where to find other Aspect models: In memory, in a local
file system, in a remote model repository etc. This is done using a _resolution strategy_, which is a function from some
type `T` to a `Try` of a RDF model. Several commonly used resolution strategies are readily available:

* The `FileSystemStrategy` resolves a `java.nio.file.Path` for a file relative
  to the xref:tooling-guide:samm-cli.adoc#models-directory-structure[models directory]
* The `ClassPathStrategy` resolves a model from resources in the Java class path
* The `EitherStrategy` can be used to chain two different strategies of different types

To implement custom resolution strategies (e.g., to resolve models against a different blob storage API), you can base
your implementation on the `AbstractResolutionStrategy`. Using the model resolver requires at least one resolution
strategy that can resolve `AspectModelUrn`&#8203;s (because references in an Aspect model to external model elements use
their respective URNs) and can use another resolution strategy, for example for file paths. The following sections show
examples for the different variants.

[[loading-an-aspect-model-rdf-level]]
=== Loading an Aspect Model to work on the RDF Level

The following example shows how to use the `AspectModelResolver` to load an Aspect Model

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelRdf.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelRdf.java[tags=loadAndResolveFromFile]
----

<1> The file must be located in a directory according to the
xref:tooling-guide:samm-cli.adoc#models-directory-structure[models directory] structure.
<2> You can check if loading succeeded using `versionedModel.isSuccess()` and
`versionedModel.isFailure()`. If loading fails, `versionedModel.getCause()` provides more
information.
<3> The code inside `forEach` is only executed if the model could be loaded successfully.
<4> List all statements in the RDF model that declare a `samm:Aspect`.

If you want to choose which model resolution strategy is used, you use the `resolveAspectModel()`
method of the `AspectModelResolver`. In this case, you need to provide the resolution strategy and
the initial input (`InputStream`, `Model` or a `String` containing RDF/Turtle), or one or more URNs
of model elements to resolve - have a look at the methods provided by `AspectModelResolver`.

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelRdf.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelRdf.java[tags=loadAndResolveFromUrn]
----

To include the model resolver artifact, use the following dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-resolver-artifact.adoc[]

[[loading-an-aspect-model-java-model-level]]
=== Loading an Aspect Model to work on the Java Aspect Model Level

If you have retrieved a `Try<VersionedModel>` as shown above, you can use the `AspectModelLoader` to
turn the RDF graph representation of the Aspect Model into a type-safe Java object. You can use the
`getElements()` method to get all model elements from the Aspect Model, or, if you expect the model
to contain exactly one Aspect (for example in unit tests), you can use the `getSingleAspect()` method.

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelObjects.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadAspectModelObjects.java[tags=loadModel]
----

To include the Java Aspect model artifact, use the following dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-meta-model-java-artifact.adoc[]

[[serializing-an-aspect-model]]
=== Serializing a Java Aspect Model into a RDF/Turtle Aspect Model

There are two serialization components available: One to turn a Java Aspect model into a Jena RDF model (the reverse
operation of what the `AspectModelLoader` does) and one to serialize the resulting Jena RDF model in Turtle syntax,
formatted according to the guidelines described in the SAMM specification.

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$SerializeAspectModel.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$SerializeAspectModel.java[tags=serialize]
----

To include the serializer artifact, use the following dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-serializer-artifact.adoc[]

[[validating-aspect-models]]
== Validating Aspect Models

Aspect Models are validated using the `AspectModelValidator`. Validation returns a list of
`Violation`&#8203;s. A violation has a human-readable message and a unique error code and provides access
to the `EvaluationContext` which contains references to the model element that caused the
violation and the SHACL shape that triggered the violation.

Each possible type of violation is a subtype of the `Violation` interface and provides additional
context information specific to this type, for example, the `MinLengthViolation` provides `int min`
(the allowed length) and `int actual` (the length that was encountered in the model).

Consider the following example:

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$ValidateAspectModel.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$ValidateAspectModel.java[tags=validate]
----

<1> To format the validation result into an human-readable form, use the `ViolationFormatter` or the
`DetailedViolationFormatter`. Note that those are only intended for text-based interfaces such as
CLIs.
<2> Every application dealing with validation results that needs to transform the results into some
different structure should instead implement the `Violation.Visitor` Interface with a suitable target
type `(String` used as an example here) and use the visitor to handle the different types of
Violations in a type-safe way.

To include the model validator, use the following dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-validator-artifact.adoc[]

[[generating-documentation]]
== Generating Documentation for Aspect Models

Different types of artifacts can be generated from an Aspect model. All corresponding generators are included in the
following dependency:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-document-generators-artifact.adoc[]

The documentation generation APIs provide methods that take as an argument a `Function<String, java.io.OutputStream>`.
This is a mapping function that takes a file name as an input (which is determined by the respective generator) and
returns a corresponding `OutputStream`, for example (but not necessarily) a `FileOutputStream`. By providing this
function when calling the generator method, you can control where the output is written to, even when the generator
creates multiple files. For the code examples in the following subsections, we assume that the following method is
defined for calling the generators:

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$AbstractGenerator.java[tags=outputStream]
----

[[generating-diagrams]]
=== Generating SVG or PNG Diagrams

Using the `AspectModelDiagramGenerator`, automatically layouted diagrams can be created for Aspect models in the formats
PNG, SVG and https://www.graphviz.org/[Graphviz/DOT].

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateDiagrams.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateDiagrams.java[tags=generate]
----

<1> The diagram generator is initialized with the loaded model.
<2> The simple call for one output format and one language (i.e., descriptions and preferredNames of one locale) takes
one output stream to write the image to.
<3> It is also possible to generate multiple diagrams, one for each combination of output format and language. For that,
the set of target formats is given as well as a mapping function.

[[generating-html-documentation]]
=== Generating HTML Documentation

A HTML reference documentation for an Aspect model can be generated as shown in the following code sample. The
documentation contains an overview diagram and describes the model elements as specified in the Aspect model. Preferred
names and descriptions in the respective language from the Aspect model are shown in the resulting document as part of
each model element.

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateHtml.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateHtml.java[tags=generate]
----

<1> Load and select the Aspect from the loaded model for which generation should be generated.
<2> The HTML generator is initialized with the context consisting of the loaded RDF model and the
selected Aspect.
<3> HTML generation can be controlled via a map of options; using an empty map implies default values.

[[generating-sample-json-payload]]
=== Generating Sample JSON Payload

The sample JSON payload generator is used to create a valid JSON payload for an Aspect model as it could be returned by
an Aspect that implements that Aspect model. This follows the
xref:samm-specification:ROOT:payloads.adoc#mapping-to-json[mapping rules] as defined in the Meta Model specification.
The generator uses `samm:exampleValue`&#8203;s of Properties if present, otherwise random values corresponding to the
respective data types are generated.

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJsonPayload.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJsonPayload.java[tags=generate]
----

=== Generating JSON Schema

The JSON schema generator creates a https://json-schema.org/[JSON Schema] that describes the payload for an Aspect model
as it could be returned by an Aspect that implements that Aspect model.

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJsonSchema.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJsonSchema.java[tags=generate]
----

=== Generating OpenAPI Specification

The OpenAPI specification generator creates either a https://json-schema.org/[JSON Schema] or a https://yaml.org/[Yaml Spec]
that specifies an Aspect regarding to the https://github.com/OAI/OpenAPI-Specification/[OpenApi specification].
The currently used versions corresponds https://json-schema.org/specification-links.html#draft-4[Draft 4] of the JSON Schema specification,
and https://github.com/OAI/OpenAPI-Specification/blob/3.0.1/versions/3.0.1.md[3.0.1].

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateOpenApi.java[tags=imports]
----
++++
</details>
++++

.Generate OpenAPI YAML
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateOpenApi.java[tags=generateYaml]
----

.Generate OpenAPI JSON
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateOpenApi.java[tags=generateJson]
----

NOTE: For Enumerations with complex data types, the values are modelled as instances of the Entity defined as the
Enumeration's data type (see xref:samm-specification:ROOT:modeling-guidelines.adoc#declaring-enumerations[Declaring
Enumerations] for more information). In case the Entity instances contain Properties with a sorted collection as their
data type, the order of the values of said collection in the Entity instances is not preserved in the generated OpenAPI
specification. Preserving this order in OpenAPI is not possible at this point.

[[generating-java-code]]
== Generating Java Code for Aspect Models

Java code can be generated from an Aspect model in two ways:

. The generated code represents the Aspect payload. Aspects and Entities become Java classes; their Properties become
fields in the classes. Characteristics are not first-class elements, but are implicitly represented by the usage of
corresponding data types (e.g. using `java.util.Set` as the type for the `Set` Characteristic of a Property) or
`javax.validation` annotations. The generated classes can be used in a straightforward fashion, but they do not contain
information about the underlying Aspect model such as its version number. Parts of the Aspect model that have no
representation in its corresponding JSON payload are not part of those classes either, in particular descriptions and
preferred names. These classes are called POJOs (Plain Old Java Objects), as they do not contain logic but serve mainly as data containers.

. The generated code represents the Aspect model itself: It is a type-safe variant of the model and includes every
information that is also present in the model such as Characteristics, descriptions including language tags and original
XSD data types. It is however not intended to store payload corresponding to an Aspect. Theses classes are called static
meta classes, because they are created at compile time (_static_) and talk about the structure of the information, not
the information itself (_meta_).

Depending on the use case, you would either use one or both of the types simultaneously.

To include the Java generator, use the following dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-java-generator-artifact.adoc[]

[[type-mapping]]
=== Type Mapping

In the Java code generated from an Aspect model, the scalar Aspect model
xref:samm-specification:ROOT:datatypes.adoc#data-types[data types] are mapped to native Java types. The following table
lists the correspondences.

[width="100%", options="header", cols="50,50"]
|===
| Aspect model type | Java native type
| `xsd:string`  | `java.lang.String`
| `xsd:boolean` | `java.lang.Boolean`
| `xsd:decimal` | `java.math.BigDecimal`
| `xsd:integer` | `java.math.BigDecimal`
| `xsd:double` | `java.lang.Double`
| `xsd:float` | `java.lang.Float`
| `xsd:date` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:time` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:dateTime` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:dateTimeStamp` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:gYear` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:gMonth` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:gDay` | `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:gYearMonth` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:gMonthDay` |  `javax.xml.datatype.XMLGregorianCalendar`
| `xsd:duration` | `javax.xml.datatype.Duration`
| `xsd:yearMonthDuration` | `javax.xml.datatype.Duration`
| `xsd:dayTimeDuration` | `javax.xml.datatype.Duration`
| `xsd:byte` | `java.lang.Byte`
| `xsd:short` | `java.lang.Short`
| `xsd:int` | `java.lang.Integer`
| `xsd:long` | `java.lang.Long`
| `xsd:unsignedByte` | `java.lang.Short`
| `xsd:unsignedShort` | `java.lang.Integer`
| `xsd:unsignedInt` | `java.lang.Long`
| `xsd:unsignedLong` | `java.math.BigInteger`
| `xsd:positiveInteger` | `java.math.BigInteger`
| `xsd:nonNegativeInteger` | `java.math.BigInteger`
| `xsd:negativeInteger` | `java.math.BigInteger`
| `xsd:nonPositiveInteger` | `java.math.BigInteger`
| `xsd:hexBinary` | `byte[]`
| `xsd:base64Binary` | `byte[]`
| `xsd:anyURI` | `java.net.URI`
| `samm:curie` | `org.eclipse.esmf.metamodel.datatypes.Curie`
|===

[[generating-pojos]]
=== Generating POJOs

POJO generation is straightforward; there are two minor differences to the generation of documentation artifacts.
Firstly, when instantiating the generator, you pass a flag indicating whether
https://en.wikipedia.org/wiki/Jackson_(API)[Jackson] annotations should be generated in the class. Secondly, the name
mapping function passed to the generation method takes a `QualifiedName` instead of a String, so that you can decide how
to handle the package structure of the class.

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJavaPojo.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJavaPojo.java[tags=generate]
----

[[generating-static-meta-classes]]
=== Generating Static Meta Classes

For the generation of static meta classes, consider the following example:

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJavaStaticClass.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateJavaStaticClass.java[tags=generate]
----

To use the generated static meta classes, you need the following additional dependency:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-static-meta-model-java-artifact.adoc[]

[[providing-custom-macros-for-code-generation]]
==== Providing Custom Macros for Code Generation

It is possible to change predefined sections of the generated classes by providing custom https://velocity.apache.org/[Velocity] templates; see the https://velocity.apache.org/engine/2.3/user-guide.html[Velocity User Guide] for more information.
The custom macros must be defined in a single template file.
The path to the template file as well as its name may be passed as arguments to the code generation, e.g. using the xref:samm-cli.adoc#samm-cli[SAMM-CLI].

Custom macros may be provided for the following sections:

[width="100%",options="header"]
|===
| Section | Macro Name | Default Macro Provided
| Copyright Licence Header | fileHeader | {nok}
|===

NOTE: When using custom macros, macros for all sections above must be provided.

Example:

[source,indent=0]
----
include::example$sample-file-header.vm[]
----

[[migrate-meta-model-version]]
== Programmatically migrate the Meta Model Version

The meta model version migrator provides functionality to automatically migrate an Aspect model that
uses an older version of the Aspect Meta Model to an Aspect model that uses a newer (usually the
latest) version of the meta model. Calling this functionality is _only_ required if you intent to
work with the raw RDF model (i.e., the `VersionedModel`). If you use the `AspectModelLoader` to load
a model into `ModelElement`&#8203;s or `Aspect`&#8203;s, calling the `MigratorService` is not
necessary, as it will be done automatically if necessary.

The following sample shows usage of the migration:

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$MigrateAspectModel.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$MigrateAspectModel.java[tags=migrate]
----

To use the meta model version migrator, you need the following dependency:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-meta-model-version-migrator-artifact.adoc[]

[[accessing-samm-programmatically]]
== Accessing the SAMM programmatically

In order to access the source RDF files that describe the SAMM vocabulary, shared Characteristics and Entities as well
as Units, you can add a dependency to the `esmf-aspect-meta-model` artifact. Note that this artifact does not contain any
Java classes.

include::esmf-developer-guide:ROOT:partial$aspect-meta-model-artifact.adoc[]

In order to access the files via `java.lang.Class#getResourceAsStream`, you can refer to the following directory
structure that is present in the artifact:

[source,subs="attributes+,+quotes"]
----
.
├── characteristic
│   └── {aspect-meta-model-version}
│       ├── characteristic-definitions.ttl
│       ├── characteristic-instances.ttl
│       ├── characteristic-shapes.ttl
│       └── characteristic-validations.js
├── entity
│   └── {aspect-meta-model-version}
│       ├── FileResource.ttl
│       ├── ThreeDimensionalPosition.ttl
│       └── TimeSeriesEntity.ttl
├── meta-model
│   └── {aspect-meta-model-version}
│       ├── aspect-meta-model-definitions.ttl
│       ├── aspect-meta-model-shapes.ttl
│       ├── prefix-declarations.ttl
│       └── type-conversions.ttl
└── unit
    └── {aspect-meta-model-version}
        └── units.ttl
----

TIP: If you use the artifact `aspect-model-resolver` instead (see section <<loading-and-saving>> for infos on the
dependency) you can directly refer to the RDF files using a resource URL:

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadMetaModelRdf.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$LoadMetaModelRdf.java[tags=loadMetaModelRdf]
----

[[mapping-aas]]
== Mapping Aspect Models to Asset Administration Shell (AAS) Submodel Templates

The Asset Administration Shell (AAS) and its
https://www.plattform-i40.de/IP/Redaktion/EN/Standardartikel/specification-administrationshell.html[information
model] is a widely recognized standard developed by the https://industrialdigitaltwin.org[Industrial
Digital Twin Association (IDTA)] to express and handle Digital Twins. Central element of the AAS is
the concept of Submodels, which describe certain aspects of a Digital Twin.

The SAMM Aspect Meta Model allows to specify aspects of a digital twin and its semantics. The AAS
Generator module provides mapping implementations to derive AAS Submodels from SAMM Aspect Models.
On the one hand, this allows to integrate SAMM models in AAS environments and on the other hand it
allows AAS submodels to be described with rich semantics, as it is possible with SAMM.

[[details-mapping-aas]]
=== Details of the Mapping Concept

In the following section, the mapping rules applied by the generator are explained. The rules apply
to https://eclipse-esmf.github.io/samm-specification/2.0.0/index.html[SAMM v2.0.0] and
https://www.plattform-i40.de/IP/Redaktion/EN/Downloads/Publikation/Details_of_the_Asset_Administration_Shell_Part1_V3.html[AAS
Specification Part 1 V3.0RC01].

[cols="1,1,2"]
|===
| SAMM  | AAS  | Comment

| **samm:Aspect**  |  aas:Submodel with kind=Template  | Empty Asset and AssetAdministrationShell entries are added to the output file

| samm:name   | aas:Submodel.idShort  |

| samm:preferredName   | aas:Submodel.displayName  |

| samm:description   | aas:Submodel.description  |

| samm:property   | see **samm:Property**  |

| samm:operation   | see **samm:Operation**   |

| samm:Aspect.urn  | aas:Submodel.semanticId  |

| **samm:Property**  | aas:Property, aas:SubmodelElementCollection   | The AAS type is derived from the type of the SAMM Characteristic specifying the SAMM property. Depending on the type it is decided what the resulting AAS element will be. In case of an Entity it will result in a SubmodelElementCollection. It will also be a SubmodelElementCollection if the SAMM Characteristic is of a Collection type (see the https://eclipse-esmf.github.io/samm-specification/2.0.0/characteristics.html[Characteristics taxonomy]). In all other cases an aas:Property will be generated

| samm:Property.name  | aas:Property.idShort |

| samm:Property.urn  | aas:ConceptDescription.identification.id, aas:Property.semanticId|

| samm:Property.preferredName   | aas:Property.displayName  |

| samm:Property.description   | aas:Property.description  |  Note: Also mapped to aas:DataSpecificationIEC61360.definition of the aas:ConceptDescription of this property

| samm:Property.exampleValue  |aas:Property.value  |

| samm:Characteristic.dataType  | aas:Property.valueType |

| **samm:Operation** |  Operation  | in/out parameters are not used in SAMM so the mapping only generates input variables and output variables in AAS

| xref:samm-specification:ROOT:characteristics.adoc#characteristic-characteristic[**samm-c:Characteristic**]  | aas:SubmodelElement, aas:ConceptDescription  | Characteristics in SAMM define the semantics of a property, which includes there types as well as links to further definitions (standards, dictionaries, etc), a natural language description and name in different languages. Type and description are separated in AAS, which is why there is not a one-to-one mapping of a Characteristic to one element in AAS but rather Characteristics are used in the mapping of Properties, first, to guide the generation process and, second, to capture semantics in ConceptDescriptions of properties with data specification "DataSpecificationIEC61360" of the AAS.

| xref:samm-specification:ROOT:characteristics.adoc#collection-characteristic[**samm-c:Collection**] | aas:SubmodelElementList, aas:ConceptDescription  | The general remarks to Characteristics apply also to Collection type Characteristics. However, properties referencing Collections are mapped to SubmodelElementLists. Specific properties of collections are mapped. samm:Set is unique, samm:SortedSet is unique and sorted, samm:List is sorted.

| xref:samm-specification:ROOT:characteristics.adoc#quantifiable-characteristic[**samm-c:Quantifiable**]  | aas:SubmodelElement, aas:ConceptDescription | The general remarks to Characteristics apply also to Quantifiable type Characteristics. Quantifiables (also Duration and Measurement) reference a unit, which is added to the ConceptDescription corresponding the mapped Characteristic.

| xref:samm-specification:ROOT:characteristics.adoc#either-characteristic[**samm-c:Either**]  | aas:SubmodelElement, aas:ConceptDescription | The general remarks to Characteristics apply also to Either. However, the Either characteristic has two distinct entries of which one is to be selected. This concept is not present in AAS. Thus, both entries will be written to a Submodel template, where one has to be ignored.

| xref:samm-specification:ROOT:characteristics.adoc#trait-characteristic[**samm-c:Trait**]  | aas:SubmodelElement, aas:ConceptDescription | The general remarks to Characteristics apply also to Trait. However, the constraint of a trait will be ignored and only the base type will be evaluated, which will act as the characteristic of a property.

| xref:samm-specification:ROOT:characteristics.adoc#code-characteristic[**samm-c:Code**] | aas:SubmodelElement, aas:ConceptDescription | Similar to plain Characteristic.

| xref:samm-specification:ROOT:characteristics.adoc#structured-value-characteristic[**samm-c:StructuredValue**]  | aas:SubmodelElement, aas:ConceptDescription | The general remarks to Characteristics apply also to StructuredValue. However, AAS has no concpet like deconstruction rule. Thus, the deconstruction rule and the sub properties of the deconstruction entity will be ignored and only the Characteristic is mapped.

| xref:samm-specification:ROOT:characteristics.adoc#enumeration-characteristic[**samm-c:Enumeration**]  | aas:SubmodelElement, aas:ConceptDescription | The general remarks to Characteristics apply also to Enumerations. Additionally, the values of an Enumeration are mapped to a valueList of a DataSpecificationIEC61360.

| xref:samm-specification:ROOT:characteristics.adoc#state-characteristic[**samm-c:State**]  | aas:SubmodelElement, aas:ConceptDescription | Same as Enumeration.

| xref:samm-specification:ROOT:characteristics.adoc#MultiLanguageText[samm-c:MultiLanguageText]  | aas:MultiLanguageProperty | if a MultiLanguageText is used in SAMM it is mapped to the MultiLanguageProperty in AAS.
|===

=== Known Limitations
The AAS Generator implements a base set of features, which are mapped from SAMM to AAS.
However, there are still limitations:

* Predefined entity mapping (FileResource would be mapped to aas:File)
* samm-c:Either is mapped to aas:SubmodelElementCollection with two entries for left and right side
* Recursive optional properties of SAMM model are not included in output but dropped straight away

=== Calling AAS generation from Java

The following code demonstrates how the API is used:

++++
<details>
<summary>Show used imports</summary>    
++++
[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateAas.java[tags=imports]
----
++++
</details>
++++

[source,java,indent=0,subs="+macros,+quotes"]
----
include::example$GenerateAas.java[tags=generate]
----

To include the serializer artifact, use the following dependencies:

include::esmf-developer-guide:ROOT:partial$esmf-aspect-model-aas-generator-artifact.adoc[]
